# Правила и съвети, които да спазвате при създаването на програмен код

Тук ще отбележим, някои основни правила и съвети, които да спазвате, когато пишете код. 

Първата част са главно съвети свързани с правилното представяне на кода, което до огромна степен помага както на вас така и на други хора, когато четат/проверяват вашия код. 

1. Именувайте променливите с имена, които могат да дадат информация за какво тази променлива се използва. Имайте предвид, че сега пишете кода и имате идея кое какво е, но ако седнете след седмица да четете какво сте писали ви гарантирам, че няма да е така и ще си губите времето в разшифроване. Също така не помагате и на проверяващия, а той няма и да има бегла представа какво сте писали. 

        Пример:
        Искаме да изчислим по подадени цена на литър за гориво, капацитет на резервоар на автомобил и разход на автомобила за 100 километра, колко път можем да изминем и колко ще струва съответно. Ако кръстим променливите a1, a2, a3, b и c, то четящия от друга страна може бая да се чуди какво се случва. Сега пишете една програма и контекста може да подскаже, но в бъдеще нещата стават повечко за писане и ако навсякъде ползвате не интуитивни имена то бая може да си навредите сами на себе си като се наложи да оправяте нещо (да не говорим в какъв възторг ще е проверяващия контролни, изпити, проекти и тн.).  

2. Форматирайте си кода. Тук нямате много оправдание тъй като почти всеки текстов редактор има тази опция автоматично да ви форматира кода. Това също не е правило, което да касае правилното изпълнение на вашата програма, но четенето на кода става много по-лесно и ако се стигне до грешно затваряне на блокови скоби, което вече е грешен код, лесно се открива.

3. Това не се отнася до форматирането на код но е много важна стъпка при писането на такъв. Винаги си премисляйте алгоритъма на хартия (или paint, което върши работа :D): напишете си основните стъпки през, които искате да минете, надраскайте си една блок схема на кода и си разиграйте с примерен вход какво вашия алгоритъм ще изплюе. Действително това пести много време при писане на код (от страна на логика, ако не знаете синтаксиса е друга историята). Oчевидно е по-добрe да имате идея какво искате да напишете, от колкото да пишете триете пишете триете.. и така докато и вие самите забравите какво искате да правите в крайна сметка.

Втората част касае важни правила, които да спазвате при писането на код. Често използвате синтаксиси, които са валидни за компилатора, но са изключително грешни относно реализиране на код, Това е поради факта, че в C++ имате огромна власт над ресурсите на компютъра, но малко опит и знания кое как се случва. За това ще изредим основни правила за следните неща.

1. Създаване на променливи

    Човек ще си каже "*Какво толкова специално има при създаването на променливи?*". Действително е така. Пишеш типа на данните, името на променливата, лепваш една точка и запетая и си бог. Ама често се забравя (или не се знае), че като създавате променлива тя отива някъде в паметта и приема стойността, които битовете образуват на тази позиция. Това може да доведе до сериозни главоблъсканици, ако използвате тази променлива в калкулации без преди да сте ѝ задали стойност (отделно прави проблеми при указателите, но за това по късно). Така че при *всяко* * създаване на променлива слагайте ѝ някаква стойност по подразбиране, за да не се чудите защо брояча ви почва от -6432031. 
    
    *Ако сте сигурни, че променлива ще получи някаква стойност преди да я използвате някъде, не е нужно. Тук се налага малко да помислите, за което се извиняваме, но такъв е живота. 

1. Създаване на масиви.
    
    Масивите могат да се заделят по два начина в паметта: динамично и статично. По време на курса по УП единствено ще работим с статични масиви. Като дойде време за СДП, ще видим какво са динамично заделените, но сега само го даваме като информация, че съществува, за да ви покажем какви грешки се правят често.

    * Статично заделените масиви се декларират само с целочислена или литерална константа. Ако сложите променлива, която се въвежда от потребителя или се изчислява по време на изпълнение на програмата вече, създавате динамично заделен масив в стека, което първо е нещо, което не се препоръчва от общността на програмистите поради ред причини, и второ не ви се позволява от главния щаб.

    * Използвайте целочислени константи при създаването на масив. Изключително удобно е тези константи да са глобални. Това ви позволява лесно да променяте размера на масива, както и да променяте границите на циклите, които работят с тях. Примера е прост: Ако сте направили масива да е от 5 елемента и имате 3 фунцкии, които работят с този масив. Идва момент, в който искате този масив да е с повече или по-малко елементи. Много по-лесно е да промените само на едно място размера на масива и това да се отрази навсякъде в кода, от колкото да търсите навсякъде къде използвате размера на масива и да правите корекции. Често нещо се изпуска, което води до повече главоболие и загуба на време.

2. Цикли
    Тук единственото съществено, на което трябва да обръщате внимание, е да сте сигурни, че цикъла по някое време ще спре. 

    * Внимавайте вашия цикъл да се прекратява правилно. Никому не е нужен безкраен цикъл или цикъл, който се изпълнява винаги само веднъж.
    
    * Избирайте правилно вашия вид цикъл. В повечето случаи циклите са взаимно заменяеми, но ето конкретни вариятни, когато един вид е по-удобен от друг:
        * for цикъла е удобен ако знаете броя на итерациите. Например ако искате да принтирате масив или да въведете определен брой неща и тн.
        * while  ако не знаете точни брой итерации, но знаете критерия за прекратяване. Например ако искаме да представим едно число от десетична бройна система в двоична. Съответно условието ще е докато числото е различно от нула, а в тялото на цикъла делим числото по модул от 2, запаметяване остатъка, делим десетичното число целочислено по 10 и го запазваме обратно в същата променлива. В зависимост от числото ще има различен брой итерации, но винаги ще се стига до край на цикъла когато стане нула.
        * do-while ако искате все пак да влезнете веднъж в цикъла. Може това да е например цикъл, който позволява на потребителя да въвежда неща докато не напише някаква команда, която да прекрати цикъла. Понеже ние искаме първо потребителя да въведе, а чак накрая да се направи проверката този цикъл е удобен. Разбира се има и други варианти за реализиране на тази логика и с обикновен while

    * Не забравяйте за break и continue. Често се налага от логиката на програмата да се прекрати дадена итерация на цикъла или самия цикъл, а вие седите и се чудите колко if-elsa да сложите, за да донагласите нещата.

3. Функции

    Функциите са едни от най-важните инструменти в програмирането. Те позволяват пестенето на повтарящ се код навсякъде, като опаковате тази логика в отделна функция и просто я викате когато ви трябва. Също така четенето на код става още по лесно, защото веднъж се налага да проверите дали функцията работи коректно и после в останалата част от кода където се среща лесно се разбира какво искаме да направим. И да не забравим рекурсията.. за къде без нея. Но за правилното ползване на функции си трябват също някои правила.

    * Една функция - една задача. Ако започнете да тъпчете една функция да прави сто неща, значи ви трябват повече функции. Няма смисъл от функция, която смята периметъра на триъгълник, казва дали текущата година е високосна и дали факултетния ви номер е палиндром. Но разделени в отделни функции вършат работа (най-малкото ви решават контролното правилно). 

    * Винаги правете проверки, ако има възможност, на подадените стойности.

    * Избирайте правилно коя стойност как ще я подавате: дали като копие или като референция. Подаването на референция пести време и ресурси на компютъра, също така ви позволява да променяте оригиналните променливи, без да връщате стойности и да правите присвоявания. Не забравяйте, че ако подавате обект като референция, ако не искате да го променяте, го правете константна референция. Например за въвеждане на масив (статичен), трябва да подадем масива. Понеже името на масива е указател към местоположението на първия елемент в паметта не е нужно да го подаваме като референция. Обаче след като се изпълни функцията, как програмата ще запомни колко елемента сме въвели. Един вариант е да върнем размера. Другия е като подадем променлива по референция, която директно да въведем във функцията. Втория вариант е една идея по-удобен и четим, защото в извикващата функция не е нужно да правите присвояване, а само извиквате функцията и подавате обектите.

4. Рекурсия

    Рекурсията е изключително мощен инструмент. Той позволява една логика да е реализирате на няколко реда, но за сметка на това яде памет. Също така позволява изпълнението на алгоритми, които не можем линейно да реализираме. Основни примери са n-то число на фибоначи, някои сортирания, но основно приложение намира в обхождането на нелинейни структури (дървета, графи), които ще срещнете по СДП.

    Изграждането на начин на мислене първоначално става по-сложно, но с достатъчно упражнение се свиква и нещата стават елементарни. Първото нещо, което трябва да се знае е как изобщо се представят функциите в компютъра. За нас те на екрана са просто редове от код. Но в паметта нещата стоят по-различно. Алгоитъм и промеливите са две различни неща за компютъра, така че на едно място седи алгоритъма в паметта а в друга част седят променливите. При извикане на фунцкия не се копира алгоритъма за изпълнение. Той си седи като команди някъде в паметта и процесора просто си ги изпълнява, когато му потрябва. Друга е ситуацията с променливите на функцията. За всяко извикване на фунцкия се заделя в паметта толкова място колкото е нужно за дадената фунцкия. Това включва променливите на функцията, списъка с параметри и още някои стойности, които не ни интересуват на този етап. Този блок от стойности в паметта се нарича стекова рамка и точно тя разграничава стойностите на едното извикване на фунцкията от друга такава. Другото съществено нещо е, че програмата се изпълнява линейно (изключваме за сега мултитрединг, защото няма да го ползваме). Не може на една стъпа от кода да създаде едновременно две състояния. Например при пресмятане на петото число на фибоначи не можем едновременно да намери третото и четвъртото. Първо намираме едното после дугото. Как обаче компютъра пони от къде идва, на къде след това трябва да отиде и т.н.? Еми това става като тъй наречените стекови рамки се поставят в програмия стек (от там им идва името). Стека работи на прост принципи. Което първо влезе първо излиза. Може да си го представите като шиш, на който можете да слагате или махате дискове само от един край. Така данните за текущо изпълняваната функция са всъщност най-горния елемент на шиша. Ако тази фунцкия извика друга то заделената стекова рамка се пъха на шиша и става тя текущо изпълнявана. А когато се приключи дадена функция то стековата рамка се маха от шиша и елемента под него става текущо изпълнявана фунцкия.

    *Забележка: Махането и слагането на стекови рамки е абстракция. Не е като физически да се слагат неща и махат неща в паметта. Просто се при извикване на функция се заделя нова памет за дадените променливи и се указва къде е текущата стекова рамка за изпълнение или при прекратяване на фунцкията просто се връщаме в предишанта стекова рамка, старата информация си седи там в паметта където си е била и не се премахва, но просто компютъра счита че тази памет там не се ползва вече и е годна за бъдеща употреба. 

    Като цяло единственото нещо, което е абсолютно важно за всички рекурсивни алгоритми е момента кога ще се прекрати самата рекурсия. Това наричаме дъно. Например дъното при числата на фибоначи, ще са първото и второто тъй като те са дефинирани. При обхождане на дърво ще е досигането на листо.
